# PCM原始音频数据格式介绍
[TOC]
## 什么是PCM

PCM全称Pulse-Code Modulation，翻译一下是脉冲调制编码。

其实大可以不用关心英文释义，之所以这么命令是因为一些历史原因。

在音视频中，**PCM是一种用数字表示采样模拟信号的方法**。

要将一段音频模拟信号转换为数字表示，包含如下三个步骤：

1. **Sampling**(采样)
2. **Quantization**(量化)
3. **Coding**(编码)

通常，我们可以通过一条曲线在坐标中显示连续的模拟信号，如下图所示：

![pulse_signal](/Users/heli/github/ffmpeg-leaning/pcm/analog_signal.png)

为了更容易理解PCM，取其中一段来说明。

![an_analog_signal](/Users/heli/github/ffmpeg-leaning/pcm/an_analog_signal.png)

假设这表示一段一秒的音频模拟信号。

![sampling](/Users/heli/github/ffmpeg-leaning/pcm/sampling.png)

## Sampling（采样）

**Sampling(采样)处理**，实际上就是让采样数据能够完全表示原始信号，且采样数据能够通过重构还原成原始信号的过程，如上图。

将采样后的图拿出来单独解释：

![sampling01](/Users/heli/github/ffmpeg-leaning/pcm/sampling01.png)

* **红色曲线**：表示原始信号。
* **蓝色垂直线段**：表示当前时间点对原始信号的一次采样。**采样**是一系列基于**振幅（amplitude）**和相同时间间隔的样本。这也是为什么采样过程被称为PAM的原因。
* **PAM**：（Pulse Amplitude Modulation)是一系列离散样本之的结果。

### 采样率(Sample rate)

每秒钟的样本数也被称之为**采样率（Sample rate）**。在**Sampling**图示案例中，采样率为每秒34次。意味着在一秒的时间内，原始信号被采样了34次（也就是蓝色垂直线段的数量）。

通常，采样率的单位用**Hz**表示，例如**1Hz**表示每秒钟对原始信号采样一次，1KHz表示每秒钟采样1000次。1MHz表示每秒钟采样1百万次。

根据场景的不同，采样率也有所不同，采样率越高，声音的还原程度越高，质量就越好，同时占用空间会变大。

例如：通话时的采样率为8KHz，常用的媒体采样率有44KHz，对于一些蓝光影片采样率高达1MHz。

## Quantization（量化）

原始信号采样后，需要通过量化来描述采样数据的大小。如图：

![quantizing](/Users/heli/github/ffmpeg-leaning/pcm/quantizing.png)

**量化处理过程**，就是将时间连续的信号，处理成时间离散的信号，并用实数表示。这些实数将被转换为二进制数用于模拟信号的存储和传输。

在图例中，如果说采样是画垂直线段的话，那么量化就是画水平线，用于衡量每次采样的数字指标。如图：

![quantizing01](/Users/heli/github/ffmpeg-leaning/pcm/quantizing01.png)

图中，每条横线表示一个等级（level）。

为了更好的描述量化过程，先来介绍一下**bit-depth（位深）**：用来描述存储数字信号值的bit数。较常用的模拟信号位深有：

* 8-bit：2^8 = 256 levels，有256个等级可以用于衡量真实的模拟信号。
* 16-bit：2^16 = 65,536 levels，有65,536个等级可以用于衡量真实的模拟信号。
* 24-bit：2^24 = 16,666,216 levels，有16,666,216个等级可以用于衡量真实的模拟信号。

显而易见，位深越大，对模拟信号的描述将越真实，对声音的描述更加准确。

在当前例子中，如果用为**8-bit位深**来描述的话，就如下图所示：

![quantizing02](/Users/heli/github/ffmpeg-leaning/pcm/quantizing02.png)

**量化的过程**就是将一个**平顶样本**四舍五入到一个可用最近level描述的过程。如图中**黑色加粗梯形折线**。量化过程中，我们将尽量让每个采样和一个level匹配，因为每个level都是表示一个bit值。

图中，第9次采样的**平顶样本**对应的level用十进制表示为255，也就是二进制的1111 1111。

## Encoding（编码）

![encoding](/Users/heli/github/ffmpeg-leaning/pcm/encoding.png)

在编码这一步，我们会将时间线上的每个sample数据转化为对应的二进制数据。

采样数据经过编码后产生的二进制数据，就是PCM数据。PCM数据可以直接存储在介质上，也可以在经过编解码处理后进行存储或传输。

## PCM数据常用量化指标

**采样率(Sample rate)**：每秒钟采样多少次，以Hz为单位。详见：**采样率(Sample rate)**一节。

**位深度(Bit-depth)**：表示用多少个二进制位来描述采样数据，一般为16bit。详见：**Quantization（量化）**一节。

**字节序**：表示音频PCM数据存储的字节序是大端存储（big-endian）还是小端存储（little-endian），为了数据处理效率的高效，通常为小端存储。

**声道数（channel number）**：当前PCM文件中包含的声道数，是单声道（mono）、双声道（stereo）？此外还有5.1声道等。

**采样数据是否有符号（Sign）**：要表达的就是字面上的意思，需要注意的是，使用有符号的采样数据不能用无符号的方式播放。

以FFmpeg中常见的PCM数据格式**s16le**为例：它描述的是**有符号16位小端PCM数据**。

s表示有符号，16表示位深，le表示小端存储。

## PCM数据流

对于PCM数据都是一些图像化的描述，那么一段PCM格式的数据流怎么表示的呢？

以8-bit有符号为例，长得像这样：

```c++
+---------+-----------+-----------+----
 binary 	| 0010 0000 | 1010 0000 | ...
 decimal	| 32        | -96       | ...
+---------+-----------+-----------+----  
```

每个分割符"|"分割字节。因为是8-bit有符号表示的采样数据，所以**采样的范围为-128～128**。

图示中表示的是两个连续采样数据的二进制和十进制表示的值。

如果我们有一个PCM文件，在代码中，我们可以通过以下方式来读取这样的PCM数据流（Stream）。

```c++
FILE *file
int8_t *buffer;
file = fopen("PCM file path");
buffer = malloc(fileSize);
fread(buffer, sizeof(int8_t), fileSize / sizeof(int8_t), file);
```

伪代码仅仅表示一种加载方式。但在代码中，一开始就将整个文件加载到了内存中，这是不对的。因为我们的音频数据量往往会比较大，一次性全部加载增加了内存负担，而且并不必要。

通常我们会为buffer分配一个固定的长度，例如2048字节，通过循环的方式一边从文件中加载PCM数据，一边播放。

加载好PCM数据后，需要送到音频设备驱动程序中播放，这时我们应该能听到声音。与PCM数数据一同到达驱动程序的通常还有**采样率（sample rate）**，用来告诉驱动每秒钟应该播放多少个采样数据。如果传递给驱动程序的采样率大于PCM实际采样率，那么声音的播放速度将比实际速度快，反之亦然。

OK，对于PCM数据流的存储而言，上面仅仅只是单声道。对于多声道的PCM数据而言，通常会交错排列，就像这样：

```c++
+---------+-----------+-----------+-----------+-----------+----
     FL 	|     FR    |     FL 	  |     FR    |     FL 	  |    
+---------+-----------+-----------+-----------+-----------+----
```

对于8-bit有符号的PCM数据而言，上图表示第一个字节存放**第一个左声道数据（FL）**，第二个字节放**第一个右声道数据（FL）**，第三个字节放**第二个左声道数据（FL）**...

不同的驱动程序对于多声道数据的排列方式可能稍有区别，下面是常用的声道排列地图：

```c++
2:  FL FR                       (stereo)
3:  FL FR LFE                   (2.1 surround)
4:  FL FR BL BR                 (quad)
5:  FL FR FC BL BR              (quad + center)
6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)
7:  FL FR FC LFE BC SL SR       (6.1 surround)
8:  FL FR FC LFE BL BR SL SR    (7.1 surround)
```

## 音量控制

音量的表示实际上就是量化过程中每个采样数据的level值，只要适当的增大或者缩小采样的level就可以达到更改音量的目的。

但需要说明的是，并是不将level值*2就能得到两倍于原声音的音量。

因为如下两个原因：

* **数据溢出**：我们都知道每个采样数据的取值范围是有限制的，例如一个signed 8-bit样本，取值范围为-128～128，值为125时，放大两倍后的值为250，超过了可描述的范围，此时发生了数据溢出。这个时候就需要我们做策略性的裁剪处理，使放大后的值符合当前格式的取值区间。

  如下伪代码描述了signed 8-bit格式的声音放大两倍的裁剪处理：

  ```c++
  int16_t pcm[1024] = read in some pcm data;
  int32_t pcmval;
  for (ctr = 0; ctr < 1024; ctr++) {
      pcmval = pcm[ctr] * 2;
      if (pcmval < 128 && pcmval > -128) {
          pcm[ctr] = pcmval
      } else if (pcmval > 128) {
          pcm[ctr] = 128;
      } else if (pcmval < -128) {
          pcm[ctr] = -128;
      }
  }
  ```

* **对数描述**：平时表示声音强度我们都是用分贝（db）作单位的，声学领域中，分贝的定义是声源功率与基准声功率比值的对数乘以10的数值。根据人耳的心理声学模型，人耳对声音感知程度是对数关系，而不是线性关系。人类的听觉反应是基于声音的相对变化而非绝对的变化。对数标度正好能模仿人类耳朵对声音的反应。所以用分贝作单位描述声音强度更符合人类对声音强度的感知。前面我们直接将声音乘以某个值，也就是线性调节，调节音量时会感觉到刚开始音量变化很快，后面调的话好像都没啥变化，使用对数关系调节音量的话声音听起来就会均匀增大。

  如下图所示，横轴表示音量调节滑块，纵坐标表示人耳感知到的音量，图中取了两块横轴变化相同的区域，音量滑块滑动变化一样，但是人耳感觉到的音量变化是不一样的，在左侧也就是较安静的地方，感觉到音量变化大，在右侧声音较大区域人耳感觉到的音量变化较小。

  ![人耳感知系数](/Users/heli/github/ffmpeg-leaning/pcm/人耳感知系数.png)

    这就需要对音量值的乘数系数合理取值。具体如何取值，请参考非常专业的一篇文章：[PCM音量控制](https://blog.jianchihu.net/pcm-volume-control.html)

## 采样率调整

采样率的定义为：每秒钟采样次数。而降低增加采样率只需要以固定的频率复制或者丢弃采样数据即可。

如10Hz表示每秒钟采样10次，我们只需要将2*n(n为从0开始的值)处的采样数据舍弃，就可以得到10/2 = 5Hz的采样数据。



