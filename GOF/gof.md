# 代理模式

代理模式是对象的结构模式，代理模式是给某一个对象提供代理对象，并由代理对象控制对原对象的引用。

主要解决：使用代理模式时，通常是被代理对象不想活着不能够直接被Client端使用，于是加入代理，在Client端和被代理对象中起到隔离、中介的作用。比如，要访问的对象在远程机器或进程上，直接访问会对远程系统或服务造成很大的麻烦，我们就可以在访问该对象前加上一个对此对象的访问，参考Binder中的代理对象。

代理模式的结构如下：

![proxy](.\proxy.JPG)

总共有三个角色：

* 抽象对象：申明目标对象和代理对象共同的接口，这样，在任何使用目标对象的地方也能使用代理对象。
* 目标对象：代理对象所要代理的目标对象。
* 代理对象：内部包含目标对象的引用，从而可以再任何时候操作目标对象，代理对象拥有与目标对象类似的接口，供外部调用。但这种调用过程绝不是简单的传递关系。

# 门面模式

门面模式也被称为外观模式，它特点是隐藏系统的复杂性，向客户端提供了一个可访问系统的接口。属于结构型模式。

现在的软件系统都大而复杂，而开发者在处理复杂问题是的策略，都是"分而治之"，把一个较大的系统划分为几个小系统。

客户端要使用这个系统时，往往需要将几个小系统组合到一起，才能够完成功能，这样耦合度较高，客户端需要知道系统的细节，甚至需要处理子系统之间的关系。降低耦合度的方法是，使客户端对子系统不可见，系统向外提供一种简单的接口。这就是门面模式处理的问题场景。

门面模式的结构如下：

![facade](.\facade.JPG)

核心只有两个角色：

* 门面（Facade）角色：客户端调用该角色的方法，该角色知道各子系统原色的功能，和上下文关系。一般而言，来自客户端的请求，都将被合理的转发到个子系统中。
* 子系统角色：子系统是多个不同功能类的集合，每个子系统都可以被客户端调用，也可以被门面角色调用。对于子系统而言，门面解决只是一个特定的客户端角色而已。

# 建造者模式

建造模式是对象的创建方式，将多个子系统对象一步步构建成一个复杂对象。而客户端不需要知道子系统的细节（建造的顺序，参数）。

建造者模式的结构如下：

![Build](.\Build.JPG)

建造者模式的角色有四个：

* 导演角色（Director）：如结构图中的PlayerDirector，担任该角色的类，调用具体的建造者角色创建对象，与客户端直接打交道。需要注意的是，具体的建造者类可能不止一个，这就需要客户端告诉导演者需要哪种产品，由导演者来选择合适的具体建造者。
* 抽象建造者角色（Builder）：如结构图中的IBuilder类，该角色主要完成的任务有：1. 给出创建子系统的接口，让具体建造者继承后实现子系统的创建。2. 给出获取产品的接口，该接口中子类将实现将子系统拼接成一个完整的产品。
* 具体建造者角色（ConcreteBuilder）：如结构图中的FFPlayerBuilder，该角色与具体子系统联系紧密，它需要完成的任务有：1. 实现首相建造者，给出具体子系统实现的步骤。2. 在对应函数中拼接子系统，完成产品构造并返回给调用者。
* 产品角色（Product）：如结构图中IPlayer接口代表的内容，是建造中的复杂对象。一般来说，一个系统中可能不止一个产品类，对应不同的具体建造者，所以最好用一个接口抽象。

# 观察者模式

观察者模式是一种行为型设计模式，定义了对象间的一对多依赖关系，当一个对象发生变化时，所有依赖于它的对象都会得到通知，并做出对应操作。

观察者模式的结构如下：

![Observer](.\Observer.JPG)

观察者模式有四个角色：

* 抽象主体角色（Subject）：抽象主体角色把所有对观察者对象的引用保存到一个集合里，并提供增加、删除对象的接口和提示变化的接口，如notify();
* 具体主体角色（IDemux）：继承抽象主体角色，在状态发生变化时，给所有登记过的观察者发出通知。
* 抽象观察者角色（IObserver）：为所有具体观察者提供一个接口，在主体通知更新时更新自己。
* 具体观察者角色（IDecode）：观察者角色，需要通过观察其他对象的状态变化而改变的对象。

# 适配器模式

结构型模式，主要作用是作为两个不兼容接口之间的桥梁，该模式设计一个单一的类，该类负责加入独立或者不兼容的接口功能。例如，读卡器是内存卡和电脑之间的适配器。

适配器模式的实现，可以通过读卡器继承内存卡或者电脑的特有接口，以达到让彼此调用的目的。

# 工厂模式